---
title: "Traffic, Land Use, and Roadkill in Denmark"
author: "Miller"
date: today
format: html
execute:
  warning: false
  message: false
---

# 1. Setup
```{r}
#| label: setup

library(tidyverse)
library(sf)
library(terra)
library(here)
library(pscl)

set.seed(42)
CRS_M <- 25832  # Denmark ETRS89 / UTM zone 32N

# Denmark bounding box
dk_bbox_wgs84 <- st_bbox(c(xmin = 8.07, ymin = 54.56, 
                           xmax = 15.25, ymax = 57.75), crs = 4326)

dk_bbox_proj <- st_transform(st_as_sfc(dk_bbox_wgs84), CRS_M) %>%
  st_bbox()

cat("Setup complete!\n")
```

---

# 2. Load Data
```{r}
#| label: load-data

# Roadkill (2017-2019 to match CORINE 2018)
road_kill_dk <- read_csv(here("data", "Global Roadkill data.csv")) %>%
  filter(country == "Denmark", 
         year >= 2017, year <= 2019) %>%
  drop_na(decimalLongitude, decimalLatitude) %>%
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude"), crs = 4326) %>%
  st_transform(CRS_M) %>%
  st_crop(dk_bbox_proj)


#species_summary <- road_kill_dk %>%
#  count(vernacularName, sort = TRUE) %>%
#  filter(!is.na(vernacularName))

#print(species_summary)

# Histogram of roadkill by year
#ggplot(species_summary, aes(x = vernacularName, y = n)) +
#  geom_col(fill = "steelblue", color = "black") +
#  geom_text(aes(label = format(n, big.mark = ",")), 
#            vjust = -0.5, size = 3) +
#  labs(title = "Danish Roadkill Reports by Year",
#       x = "Year",
#       y = "Number of Reports") +
#  scale_y_continuous(labels = scales::comma, expand = expansion(mult = c(0, 0.1))) +
#  theme_minimal() +
#  theme(panel.grid.major.x = element_blank())

# Roads
roads_raw <- st_read(here("data", "OSM_dk_roads_shp", "gis_osm_roads_free_1.shp"), 
                     quiet = TRUE) %>%
  st_transform(CRS_M) %>%
  st_crop(dk_bbox_proj)

# Traffic
traffic_raw <- st_read(here("data", "ODN_dk_traffic_shp", "OPEN_DATA_NOEGLETAL_VIEWPoint.shp"), 
                       quiet = TRUE) %>%
  st_transform(CRS_M) %>%
  st_crop(dk_bbox_proj)

cat("Data loaded:\n")
cat("  Roadkill (2017-2019):", nrow(road_kill_dk), "\n")
cat("  Roads:", nrow(roads_raw), "\n")
cat("  Traffic points:", nrow(traffic_raw), "\n")
```

---

# 3. Prepare Roads
```{r}
#| label: filter-roads

# Filter to car-accessible roads
# EFFICIENCY: Filter early to reduce dataset size for all subsequent operations
car_codes <- c(5111:5115, 5121:5123, 5131:5135)

car_roads <- roads_raw %>%
  filter(code %in% car_codes) %>%
  mutate(
    len_m = st_length(geometry),
    len_km = as.numeric(len_m) / 1000
  )

cat("Car-accessible roads:", format(nrow(car_roads), big.mark = ","), "\n")
```

---

# 4. Match Traffic to Roads
```{r}
#| label: match-traffic

# EFFICIENCY: Cache distance calculations (computationally expensive)
distances_cache_file <- here("data", "distances_cache_2017_2019.rds")

if (file.exists(distances_cache_file)) {
  cat("Loading cached distances...\n")
  distances_data <- readRDS(distances_cache_file)
  nearest_idx <- distances_data$nearest_idx
  distances <- distances_data$distances
} else {
  cat("Computing distances (one-time calculation)...\n")
  
  # Prepare traffic data - select only needed columns
  traffic_trim <- traffic_raw %>% 
    dplyr::select(AAR, AADT, geometry)
  
  # Find nearest traffic point
  nearest_idx <- st_nearest_feature(car_roads, traffic_trim)
  
  # Calculate distances
  distances <- st_distance(car_roads, traffic_trim[nearest_idx, ], by_element = TRUE)
  
  # Save both for next time
  saveRDS(list(nearest_idx = nearest_idx, distances = distances), 
          distances_cache_file)
}

# Apply 75th percentile threshold
dist_threshold <- quantile(as.numeric(distances), 0.75)

roads_traf <- car_roads %>%
  mutate(
    nn_dist_m = as.numeric(distances),
    AADT = if_else(nn_dist_m <= dist_threshold, 
                   traffic_raw$AADT[nearest_idx], 
                   NA_real_)
  )

cat("Distance threshold:", format(round(dist_threshold), big.mark = ","), "m\n")
cat("Roads with traffic:", format(sum(!is.na(roads_traf$AADT)), big.mark = ","), 
    "(", round(mean(!is.na(roads_traf$AADT)) * 100, 1), "%)\n")
```

---

# 5. Process CORINE Land Cover
```{r}
#| label: process-corine

# EFFICIENCY: Cache processed CORINE (avoid reprojection every time)
#corine_cache_file <- here("data", "corine_dk_epsg25832_cache.tif")

#if (file.exists(corine_cache_file)) {
#  cat("Loading cached CORINE Denmark (EPSG:25832)...\n")
#  corine_dk <- rast(corine_cache_file)
#} else {
#  cat("Processing CORINE (one-time setup, ~2-5 minutes)...\n")
  
  # Load original CORINE
#  corine_raw <- rast(here("data", "u2018_clc2018_v2020_20u1_raster100m", 
#                          "DATA", "U2018_CLC2018_V2020_20u1.tif"))
  
#  cat("  Original CORINE CRS:", crs(corine_raw, describe = TRUE)$name, "\n")
  
  # EFFICIENCY TRICK: Crop FIRST in native CRS, THEN reproject (much faster)
  # Step 1: Transform bbox TO CORINE's CRS
#  dk_bbox_corine <- st_transform(st_as_sfc(dk_bbox_wgs84), crs(corine_raw)) %>%
#    st_bbox()
  
  # Step 2: Crop in native CRS (FAST - no transformation)
#  cat("  Cropping to Denmark extent in native CRS...\n")
#  corine_cropped <- crop(corine_raw, vect(st_as_sfc(dk_bbox_corine)))
  
  # Step 3: Reproject only the cropped portion (MUCH smaller area)
#  cat("  Reprojecting cropped CORINE to EPSG:25832...\n")
#  corine_dk <- project(corine_cropped, paste0("EPSG:", CRS_M), method = "near")
  
  # Save for future runs
#  cat("  Saving to cache...\n")
#  writeRaster(corine_dk, corine_cache_file, overwrite = TRUE)
#  cat("  Cache saved! Future runs will skip this step.\n")
#}

#cat("CORINE ready! Resolution:", res(corine_dk), "m\n")
```

---

# 6. Extract Land Cover Around Roads
```{r}
#| label: extract-landcover

# EFFICIENCY: Cache land cover extraction (most time-consuming step)
#landcover_cache_file <- here("data", "landcover_props_2017_2019.rds")

#if (file.exists(landcover_cache_file)) {
#  cat("Loading cached land cover proportions...\n")
#  lc_props <- readRDS(landcover_cache_file)
#} else {
#  cat("Extracting land cover (this will take 5-10 minutes)...\n")
  
  # EFFICIENCY: Create buffers only once
#  cat("  Creating 500m buffers...\n")
#  road_buffers <- roads_traf %>%
#    st_buffer(500)
  
  # Extract values
#  cat("  Extracting CORINE values...\n")
#  lc_values <- extract(corine_dk, vect(road_buffers))
  
  # CORINE Land Cover codes:
  # 1xx = Urban/Built (111-142)
  # 2xx = Agriculture (211-244)  
  # 3xx = Forest & Semi-natural (311-324)
  # 4xx-5xx = Wetlands & Water (411-523)
  
#  cat("  Calculating proportions...\n")
#  lc_props <- lc_values %>%
#    rename(corine_code = U2018_CLC2018_V2020_20u1) %>%  # Name the value column
#    group_by(ID) %>%
#    summarise(
#      n_cells = n(),
#      pct_urban = sum(corine_code >= 111 & corine_code <= 142, na.rm = TRUE) / n_cells * 100,
#      pct_agriculture = sum(corine_code >= 211 & corine_code <= 244, na.rm = TRUE) / n_cells * 100,
#      pct_forest = sum(corine_code >= 311 & corine_code <= 324, na.rm = TRUE) / n_cells * 100,
#      pct_wetland_water = sum(corine_code >= 411 & corine_code <= 523, na.rm = TRUE) / n_cells * 100,
#      .groups = "drop"
#    )
  
  # Save for future runs
#  saveRDS(lc_props, landcover_cache_file)
#  cat("  Cache saved! Future runs will skip this step.\n")
#}

# EFFICIENCY: Join by row number (faster than spatial join)
#roads_traf <- roads_traf %>%
#  mutate(ID = row_number()) %>%
#  left_join(lc_props, by = "ID")

#cat("Land cover extraction complete!\n")
#cat("  Mean % Forest:", round(mean(roads_traf$pct_forest, na.rm = TRUE), 1), "\n")
#cat("  Mean % Agriculture:", round(mean(roads_traf$pct_agriculture, na.rm = TRUE), 1), "\n")
#cat("  Mean % Urban:", round(mean(roads_traf$pct_urban, na.rm = TRUE), 1), "\n")
```

```{r}
# Roads
landuse_raw <- st_read(here("data", "OSM_dk_landuse_shp", "gis_osm_landuse_a_free_1.shp"), 
                     quiet = TRUE) %>%
  st_transform(CRS_M) %>%
  st_crop(dk_bbox_proj)

landuse_summary <- landuse_raw %>%
  count(fclass, sort = TRUE) %>%
  filter(!is.na(fclass))

print(landuse_summary)

# Histogram of roadkill by year
ggplot(landuse_summary, aes(x = fclass, y = n)) +
  geom_col(fill = "steelblue", color = "black") +
  geom_text(aes(label = format(n, big.mark = ",")), 
            vjust = -0.5, size = 3) +
  labs(title = "Danish Roadkill Reports by Year",
       x = "Year",
       y = "Number of Reports") +
  scale_y_continuous(labels = scales::comma, expand = expansion(mult = c(0, 0.1))) +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank())
```

---

# 7. Aggregate Roadkill by Road Segment
```{r}
#| label: aggregate-roadkill

# EFFICIENCY: Cache roadkill aggregation (spatial join is expensive)
roadkill_cache_file <- here("data", "roadkill_by_segment_2017_2019.rds")

if (file.exists(roadkill_cache_file)) {
  cat("Loading cached roadkill aggregation...\n")
  roadkill_by_segment <- readRDS(roadkill_cache_file)
} else {
  cat("Aggregating roadkill by road segment...\n")
  
  # EFFICIENCY: Select only needed column before spatial join
  roadkill_by_segment <- road_kill_dk %>%
    st_join(roads_traf %>% dplyr::select(osm_id), 
            join = st_nearest_feature) %>%
    group_by(osm_id) %>%
    summarise(roadkill_count = n(), .groups = "drop") %>%
    st_drop_geometry()
  
  saveRDS(roadkill_by_segment, roadkill_cache_file)
}

# Create final modeling dataset
model_data <- roads_traf %>%
  st_drop_geometry() %>%
  left_join(roadkill_by_segment, by = "osm_id") %>%
  replace_na(list(roadkill_count = 0)) %>%
  filter(!is.na(AADT), AADT > 0) %>%
  mutate(
    log_AADT = log(AADT),
    log_len_km = log(len_km),
    road_type = case_when(
      code %in% 5111:5115 ~ "Major",
      code %in% 5121:5123 ~ "Minor",
      TRUE ~ "Links"
    ),
    # Speed limit: convert to numeric, impute missing with median
    speed_limit = as.numeric(maxspeed),
    speed_limit = if_else(is.na(speed_limit), 
                          median(speed_limit, na.rm = TRUE), 
                          speed_limit)
  ) %>%
  dplyr::select(osm_id, roadkill_count, len_km, log_len_km, 
                AADT, log_AADT, road_type, speed_limit, fclass,
                pct_urban, pct_agriculture, pct_forest, pct_wetland_water)

cat("\n=== FINAL ANALYSIS DATASET ===\n")
cat("Total segments:", format(nrow(model_data), big.mark = ","), "\n")
cat("Segments with roadkill:", 
    format(sum(model_data$roadkill_count > 0), big.mark = ","),
    "(", round(mean(model_data$roadkill_count > 0) * 100, 1), "%)\n")
cat("Zero-inflation rate:", 
    round(mean(model_data$roadkill_count == 0) * 100, 1), "%\n")
cat("Mean roadkill per segment:", round(mean(model_data$roadkill_count), 3), "\n")
cat("Total roadkill events:", format(sum(model_data$roadkill_count), big.mark = ","), "\n")
```

---

# 8. Exploratory Data Analysis
```{r}
#| label: eda
#| fig-width: 14
#| fig-height: 10

library(patchwork)

# Traffic volume
p1 <- ggplot(model_data, aes(x = AADT, y = roadkill_count)) +
  geom_point(alpha = 0.1, size = 0.5) +
  geom_smooth(method = "loess", color = "red", se = TRUE) +
  scale_x_log10(labels = scales::comma) +
  labs(title = "Roadkill vs Traffic Volume",
       x = "AADT (log scale, vehicles/day)", 
       y = "Roadkill Count") +
  theme_minimal()

# Road type
p2 <- ggplot(model_data %>% filter(roadkill_count > 0), 
             aes(x = road_type, y = roadkill_count, fill = road_type)) +
  geom_boxplot(alpha = 0.7) +
  scale_y_log10() +
  labs(title = "Roadkill by Road Type",
       x = "Road Classification",
       y = "Roadkill Count (log scale)") +
  theme_minimal() +
  theme(legend.position = "none")

# Forest cover
p3 <- ggplot(model_data, aes(x = pct_forest, y = roadkill_count)) +
  geom_point(alpha = 0.1, size = 0.5) +
  geom_smooth(method = "loess", color = "darkgreen", se = TRUE) +
  labs(title = "Roadkill vs Forest Cover",
       x = "% Forest within 500m buffer", 
       y = "Roadkill Count") +
  theme_minimal()

# Agriculture
p4 <- ggplot(model_data, aes(x = pct_agriculture, y = roadkill_count)) +
  geom_point(alpha = 0.1, size = 0.5) +
  geom_smooth(method = "loess", color = "orange", se = TRUE) +
  labs(title = "Roadkill vs Agricultural Land",
       x = "% Agriculture within 500m buffer", 
       y = "Roadkill Count") +
  theme_minimal()

(p1 + p2) / (p3 + p4)
```

---

# 9. Hurdle Model with Road Length as Offset
```{r}
#| label: fit-model

cat("=== FITTING HURDLE MODEL ===\n")
cat("Using road length as offset to model roadkill RATE (per km)\n\n")

# Model roadkill RATE per km (length controlled via offset)
hurdle_model <- hurdle(
  roadkill_count ~ log_AADT + road_type + speed_limit + 
                   pct_forest + pct_agriculture + pct_urban |
                   log_AADT + road_type + speed_limit + 
                   pct_forest + pct_agriculture + pct_urban,
  data = model_data,
  offset = log(len_km),  # Controls for road length exposure
  dist = "negbin",
  zero.dist = "binomial"
)

cat("Model fitted successfully!\n\n")
print(summary(hurdle_model))

cat("\n=== MODEL DIAGNOSTICS ===\n")
cat("Log-Likelihood:", round(logLik(hurdle_model), 1), "\n")
cat("AIC:", round(AIC(hurdle_model), 1), "\n")
cat("BIC:", round(BIC(hurdle_model), 1), "\n")
```

---

# 10. Results & Interpretation
```{r}
#| label: results-table

# Extract coefficients and standard errors
coefs <- coef(hurdle_model)
se <- sqrt(diag(vcov(hurdle_model)))

# Create results table
results <- tibble(
  Parameter = names(coefs),
  Estimate = round(coefs, 4),
  SE = round(se, 4),
  Z_value = round(coefs/se, 2),
  P_value = round(2 * (1 - pnorm(abs(coefs/se))), 5)
) %>%
  mutate(Sig = case_when(
    P_value < 0.001 ~ "***",
    P_value < 0.01 ~ "**",
    P_value < 0.05 ~ "*",
    P_value < 0.1 ~ ".",
    TRUE ~ ""
  ))

# Number of predictors per component (intercept + predictors)
n_zero <- 7  # Intercept + 6 predictors
n_count <- 7  # Intercept + 6 predictors

cat("=== ZERO HURDLE MODEL (Does roadkill occur?) ===\n\n")
results %>% 
  slice(1:n_zero) %>%
  print(n = Inf)

cat("\n=== COUNT MODEL (How many events | roadkill > 0?) ===\n\n")
results %>% 
  slice((n_zero + 1):(n_zero + n_count)) %>%
  print(n = Inf)
```

## Interpretation

**Zero Hurdle Component** (probability of ANY roadkill):
- This models whether a road segment experiences roadkill at all
- Significant predictors affect the odds of roadkill presence

**Count Component** (intensity given presence):
- This models how many roadkill events occur, given at least one event
- Significant predictors affect the expected number of collisions

**Note on Offset**: Road length is controlled via offset, so all effects are interpreted as roadkill RATE per kilometer, not total counts.

---

# 11. Conclusions

[Add your interpretation based on which variables are significant]